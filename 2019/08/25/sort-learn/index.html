<!DOCTYPE html>
<html lang="zh-CN">


<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>
    十种常见排序算法-JAVA版 | 我想要offer
  </title>
  <meta name="description" content="有问题可以给我发邮件或者开issue，感谢关注。">
  
  <meta name="keywords" content="
  data structures,algorithm,sort,java
  ">
  
  <meta name="author" content="jqzhang">

  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">
  <meta name="theme-color" content="#1e2327">
  <link rel="apple-touch-icon" href="https://github.githubassets.com/apple-touch-icon.png">
  <link rel="apple-touch-icon" sizes="180x180" href="https://github.githubassets.com/apple-touch-icon-180x180.png">

  <link rel="icon" type="image/x-icon" href="https://github.githubassets.com/favicon.ico">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
  

  

  <script src="//cdnjs.cloudflare.com/ajax/libs/vue/1.0.25-csp/vue.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/moment.js/2.11.2/moment.min.js"></script>
</head>

<body id="replica-app">

<nav class="navbar-wrapper">
  <div class="navbar">
    <div class="container clearfix">
      <a href="/" class="navbar-logo"><i class="fa fa-github"></i></a>

      <div class="navbar-search float-left desktop-only">
        <div class="navbar-search-form">
          <label for="gsc-i-id1">This website</label>
          <div id="google-search">
            <gcse:search></gcse:search>
          </div>
        </div>
      </div>

      <ul class="navbar-nav float-left">
        
        <li><a href="/archives">Archives</a></li>
        
        
        <li><a href="/categories">Categories</a></li>
        
        
        <li><a href="/tags">Tags</a></li>
        
        
        <li class="desktop-only"><a href="/atom.xml" target="_blank">RSS</a></li>
        
      </ul>

      <ul class="navbar-nav user-nav float-right desktop-only">
        <li class="user-nav-notification">
          <a><span class="user-nav-unread"></span><i class="fa fa-bell"></i></a>
        </li>
        <li>
          <a><i class="fa fa-plus"></i> <i class="fa fa-caret-down"></i></a>
        </li>
        <li class="user-nav-logo">
          <a><img src="https://raw.githubusercontent.com/Dr-Cube/flappy-octocat/master/logo.png"> <i class="fa fa-caret-down"></i></i></a>
        </li>
      </ul>
    </div>
  </div>
</nav>

<div class="main-container">
  <header class="header-wrapper desktop-only">
  <div class="container header-site-detail">
    <ul class="header-toolbar">
      <li class="clearfix">
        <a href="/archives" class="header-toolbar-left"><i
                  class="fa fa-file-text"></i> Posts </a>
        <a href="/archives"
           class="header-toolbar-right"> 2 </a>
      </li>
      <li>
        <a href="/tags" class="header-toolbar-left"><i
                  class="fa fa-tags"></i> Tags </a>
        <a href="/tags"
           class="header-toolbar-right"> 6 </a>
      </li>
      <li>
        <a href="/categories" class="header-toolbar-left"><i
                  class="fa fa-folder-open"></i> Categories </a>
        <a href="/categories"
           class="header-toolbar-right"> 2 </a>
      </li>
    </ul>
    <h2 class="header-title">
      <i class="fa fa-book text-muted"></i>
      <a href="/">我想要offer</a>
      
      
    </h2>
  </div>

  <div class="container">
    <div class="header-tab-wrapper clearfix">
      <span class="header-tab header-tab-selected"><i class="fa fa-thumbs-o-up"></i> Like</span>
      <span class="header-tab"><i class="fa fa-share-alt"></i> Share</span>
      <span class="header-tab"><i class="fa fa-comments-o"></i> Discussion</span>
      <span class="header-tab"><i class="fa fa-bookmark-o"></i> Bookmark </span>
      <span class="header-tab"><i class="fa fa-smile-o"></i> Smile <i class="fa fa-caret-down"></i></span>
    </div>
  </div>
</header>


<div class="post-container container">
  <h3>
    <i class="fa fa-user-o"></i>
    jqzhang

    <span class="post-date float-right" title="{{moment(1566737511000).format('MMM DD, YYYY, h:mm:ss A')}}">
      <i class="fa fa-pencil-square-o"></i>
      {{moment(1566737511000).fromNow()}}
    </span>
  </h3>

  <article class="post-content">
    <h1>十种常见排序算法-JAVA版</h1>
    <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>数据结构与算法的可视化可以参考<a href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html" target="_blank" rel="noopener">Data Structure Visualizations</a></p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>十种常见的排序算法主要可分为两大类：比较类排序和非比较类排序</p>
<ul>
<li>比较类：通过对数组中的元素进行比较来实现排序，这类算法的时间复杂度下界为$\Omega(nlogn)$；</li>
<li>非比较类：利用非比较的方法获得有关输入数组中的排序信息，则可突破$\Omega(nlogn)$的复杂度下界，达到线性复杂度。</li>
</ul>
<h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><p><img src="sortlearn01.png" alt><br>本来是用的markdown表格，但是这个主题不支持表格中显示公式，所以只好用图片了。有点模糊，请见谅。</p>
<p>以下排序以数组<code>{4, 23, 7, 34, 129, 18, 0, 116, 11, 32, 25}</code>为示例。</p>
<h2 id="比较排序"><a href="#比较排序" class="headerlink" title="比较排序"></a>比较排序</h2><h3 id="1-选择排序"><a href="#1-选择排序" class="headerlink" title="1. 选择排序"></a>1. 选择排序</h3><h4 id="1-1-算法描述"><a href="#1-1-算法描述" class="headerlink" title="1.1 算法描述"></a>1.1 算法描述</h4><p>选择排序是一种最简单的排序算法，其命名原因就是不断地选择数组中的最小（大）值。首先，找到数组中最小的元素，然后将它和数组的第一个元素交换位置（如果第一个元素最小就和自己交换）。其次，在剩下的元素中找到最小的元素，将其与数组的第二个元素交换位置，如此直到将整个数组都排好序。</p>
<h4 id="1-2-代码实现"><a href="#1-2-代码实现" class="headerlink" title="1.2 代码实现"></a>1.2 代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//选择排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] SelectionSort(<span class="keyword">int</span>[] arr)</span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(<span class="string">"选择排序"</span>);</span><br><span class="line">    <span class="keyword">int</span> minIdx;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length-<span class="number">1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        minIdx = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;arr.length;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j]&lt;arr[minIdx])</span><br><span class="line">            &#123;</span><br><span class="line">                minIdx = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[minIdx];</span><br><span class="line">        arr[minIdx] = temp;</span><br><span class="line"></span><br><span class="line">        System.out.printf(<span class="string">"第%d趟结果为：%s\n"</span>, i+<span class="number">1</span>, Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-3-排序过程"><a href="#1-3-排序过程" class="headerlink" title="1.3 排序过程"></a>1.3 排序过程</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">第1趟结果为：[0, 23, 7, 34, 129, 18, 4, 116, 11, 32, 25]</span><br><span class="line">第2趟结果为：[0, 4, 7, 34, 129, 18, 23, 116, 11, 32, 25]</span><br><span class="line">第3趟结果为：[0, 4, 7, 34, 129, 18, 23, 116, 11, 32, 25]</span><br><span class="line">第4趟结果为：[0, 4, 7, 11, 129, 18, 23, 116, 34, 32, 25]</span><br><span class="line">第5趟结果为：[0, 4, 7, 11, 18, 129, 23, 116, 34, 32, 25]</span><br><span class="line">第6趟结果为：[0, 4, 7, 11, 18, 23, 129, 116, 34, 32, 25]</span><br><span class="line">第7趟结果为：[0, 4, 7, 11, 18, 23, 25, 116, 34, 32, 129]</span><br><span class="line">第8趟结果为：[0, 4, 7, 11, 18, 23, 25, 32, 34, 116, 129]</span><br><span class="line">第9趟结果为：[0, 4, 7, 11, 18, 23, 25, 32, 34, 116, 129]</span><br><span class="line">第10趟结果为：[0, 4, 7, 11, 18, 23, 25, 32, 34, 116, 129]</span><br></pre></td></tr></table></figure>

<h4 id="1-4-算法特点"><a href="#1-4-算法特点" class="headerlink" title="1.4 算法特点"></a>1.4 算法特点</h4><p>选择排序的总交换次数为N。它有两个鲜明的特点：</p>
<ul>
<li>运行时间和输入无头</li>
<li>数据移动是最少</li>
</ul>
<h3 id="2-冒泡排序"><a href="#2-冒泡排序" class="headerlink" title="2. 冒泡排序"></a>2. 冒泡排序</h3><h4 id="2-1-算法描述"><a href="#2-1-算法描述" class="headerlink" title="2.1 算法描述"></a>2.1 算法描述</h4><p>冒泡排序的基本思想就是比较相邻的元素，根据大小交换位置。算法过程如下：</p>
<ul>
<li>比较相邻元素，若前一个比后一个大，则交换两元素；</li>
<li>比较每一对相邻元素，一趟排序过后，最后一个元素即为最大元素；</li>
<li>重复这样的过程直到排序完成</li>
</ul>
<h4 id="2-2-代码实现"><a href="#2-2-代码实现" class="headerlink" title="2.2 代码实现"></a>2.2 代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//冒泡排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] BubbleSort(<span class="keyword">int</span>[] arr)</span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(<span class="string">"冒泡排序"</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length-<span class="number">1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;arr.length-i-<span class="number">1</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j]&gt;arr[j+<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = arr[j];</span><br><span class="line">                arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">                arr[j+<span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.printf(<span class="string">"第%d趟结果为：%s\n"</span>, i+<span class="number">1</span>, Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-3-排序过程"><a href="#2-3-排序过程" class="headerlink" title="2.3 排序过程"></a>2.3 排序过程</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">第1趟结果为：[4, 7, 23, 34, 18, 0, 116, 11, 32, 25, 129]</span><br><span class="line">第2趟结果为：[4, 7, 23, 18, 0, 34, 11, 32, 25, 116, 129]</span><br><span class="line">第3趟结果为：[4, 7, 18, 0, 23, 11, 32, 25, 34, 116, 129]</span><br><span class="line">第4趟结果为：[4, 7, 0, 18, 11, 23, 25, 32, 34, 116, 129]</span><br><span class="line">第5趟结果为：[4, 0, 7, 11, 18, 23, 25, 32, 34, 116, 129]</span><br><span class="line">第6趟结果为：[0, 4, 7, 11, 18, 23, 25, 32, 34, 116, 129]</span><br><span class="line">第7趟结果为：[0, 4, 7, 11, 18, 23, 25, 32, 34, 116, 129]</span><br><span class="line">第8趟结果为：[0, 4, 7, 11, 18, 23, 25, 32, 34, 116, 129]</span><br><span class="line">第9趟结果为：[0, 4, 7, 11, 18, 23, 25, 32, 34, 116, 129]</span><br><span class="line">第10趟结果为：[0, 4, 7, 11, 18, 23, 25, 32, 34, 116, 129]</span><br></pre></td></tr></table></figure>

<h3 id="3-插入排序"><a href="#3-插入排序" class="headerlink" title="3. 插入排序"></a>3. 插入排序</h3><h4 id="3-1-算法描述"><a href="#3-1-算法描述" class="headerlink" title="3.1 算法描述"></a>3.1 算法描述</h4><p>插入排序是一种简单的排序算法。通过类比整理扑克牌可以很好地理解插入排序的过程。插入排序把数组分为两个部分，左端为有序部分，右端为待插入部分。每次选择右端的第一个元素，插入到左端的相应位置，并将左端比该值大的元素依次右移，直到数组全部被排好序。</p>
<h4 id="3-2-代码实现"><a href="#3-2-代码实现" class="headerlink" title="3.2 代码实现"></a>3.2 代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] InsertionSort(<span class="keyword">int</span>[] arr)</span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(<span class="string">"插入排序"</span>);</span><br><span class="line">    <span class="keyword">int</span> cur, j;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;arr.length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        j = i;</span><br><span class="line">        cur = arr[i];</span><br><span class="line">        <span class="keyword">while</span>(j-<span class="number">1</span>&gt;=<span class="number">0</span> &amp;&amp; cur&lt;arr[j-<span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            arr[j] = arr[j-<span class="number">1</span>];</span><br><span class="line">            arr[j-<span class="number">1</span>] = cur;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.printf(<span class="string">"第%d趟结果为：%s\n"</span>, i, Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-3-排序过程"><a href="#3-3-排序过程" class="headerlink" title="3.3 排序过程"></a>3.3 排序过程</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">第1趟结果为：[4, 23, 7, 34, 129, 18, 0, 116, 11, 32, 25]</span><br><span class="line">第2趟结果为：[4, 7, 23, 34, 129, 18, 0, 116, 11, 32, 25]</span><br><span class="line">第3趟结果为：[4, 7, 23, 34, 129, 18, 0, 116, 11, 32, 25]</span><br><span class="line">第4趟结果为：[4, 7, 23, 34, 129, 18, 0, 116, 11, 32, 25]</span><br><span class="line">第5趟结果为：[4, 7, 18, 23, 34, 129, 0, 116, 11, 32, 25]</span><br><span class="line">第6趟结果为：[0, 4, 7, 18, 23, 34, 129, 116, 11, 32, 25]</span><br><span class="line">第7趟结果为：[0, 4, 7, 18, 23, 34, 116, 129, 11, 32, 25]</span><br><span class="line">第8趟结果为：[0, 4, 7, 11, 18, 23, 34, 116, 129, 32, 25]</span><br><span class="line">第9趟结果为：[0, 4, 7, 11, 18, 23, 32, 34, 116, 129, 25]</span><br><span class="line">第10趟结果为：[0, 4, 7, 11, 18, 23, 25, 32, 34, 116, 129]</span><br></pre></td></tr></table></figure>

<h4 id="3-4-算法特点"><a href="#3-4-算法特点" class="headerlink" title="3.4 算法特点"></a>3.4 算法特点</h4><p>其所需时间取决于输入元素的初始顺序，适合小规模的数组。</p>
<h3 id="4-希尔排序"><a href="#4-希尔排序" class="headerlink" title="4. 希尔排序"></a>4. 希尔排序</h3><h4 id="4-1-算法描述"><a href="#4-1-算法描述" class="headerlink" title="4.1 算法描述"></a>4.1 算法描述</h4><p>希尔排序是一种基于插入排序的快速的排序算法。插入排序对于大规模乱序数组速度很慢，这主要是因为其在插入的过程中，只交换相邻两个元素。而希尔排序则交换不相邻的元素以对数组的局部进行排序，最终用插入排序将局部有序的数组排序。希尔排序是第一个突破$O(n^2)$的排序算法。</p>
<p>希尔排序的思想是使数组中任意间隔为h的元素都是有序的，这样的数组称为h有序数组。在橙书《算法》中，希尔排序的h有序数组使用序列$1/2(3^k-1)$，从$N/3$开始递减至1。如下的实现由于数组只有10个所以用<code>1, 4, 13, 40, 121, 364, 1093, ...</code>这样的递增序列无法较为清楚地展示希尔排序的过程，因而选择使用$N/2$的方法。</p>
<h4 id="4-2-代码实现"><a href="#4-2-代码实现" class="headerlink" title="4.2 代码实现"></a>4.2 代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//希尔排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] ShellSort(<span class="keyword">int</span>[] arr)</span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(<span class="string">"希尔排序"</span>);</span><br><span class="line">    <span class="keyword">int</span> len = arr.length;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> cur, j;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> gap=len/<span class="number">2</span>;gap&gt;<span class="number">0</span>;gap=gap/<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//注意此处i的终止条件，i和简单插入排序一样要跑到最后的</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=gap;i&lt;len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            j = i;</span><br><span class="line">            cur = arr[j];</span><br><span class="line">            <span class="keyword">while</span>(j-gap&gt;=<span class="number">0</span> &amp;&amp; cur&lt;arr[j-gap])</span><br><span class="line">            &#123;</span><br><span class="line">                arr[j] = arr[j-gap];</span><br><span class="line">                arr[j-gap] = cur;</span><br><span class="line">                j -= gap;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.printf(<span class="string">"第%d趟增量为%d，结果为：%s\n"</span>, cnt, gap, Arrays.toString(arr));</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-3-排序过程"><a href="#4-3-排序过程" class="headerlink" title="4.3 排序过程"></a>4.3 排序过程</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">第1趟增量为5，结果为：[4, 0, 7, 11, 32, 18, 23, 116, 34, 129, 25]</span><br><span class="line">第2趟增量为2，结果为：[4, 0, 7, 11, 23, 18, 25, 116, 32, 129, 34]</span><br><span class="line">第3趟增量为1，结果为：[0, 4, 7, 11, 18, 23, 25, 32, 34, 116, 129]</span><br></pre></td></tr></table></figure>

<h4 id="4-4-算法特点"><a href="#4-4-算法特点" class="headerlink" title="4.4 算法特点"></a>4.4 算法特点</h4><p>希尔排序的代码量很小，且不需要额外的内存空间，对于中等大小的数组其运行时间可接受。后续介绍的归并、快排和堆排序更加高效，但除了对于很大的$N$，这些高级的排序算法可能只比希尔排序快两倍，而且更复杂。所以当需要解决一个排序问题而没有api（如嵌入式系统中）时，就可用希尔排序。</p>
<h3 id="5-归并排序"><a href="#5-归并排序" class="headerlink" title="5. 归并排序"></a>5. 归并排序</h3><h4 id="5-1-算法描述"><a href="#5-1-算法描述" class="headerlink" title="5.1 算法描述"></a>5.1 算法描述</h4><p>归并排序是一种建立在归并操作上的典型的基于分治法的排序算法。算法递归地将数组分成两半，分别排序，然后将结果归并起来。</p>
<ul>
<li>原地归并</li>
</ul>
<p>首先将复制所有元素复制到辅助数组中，然后再归并回原始数组。</p>
<blockquote>
<p>方法在归并时进行了4个条件判断：左半边用尽（取右半边的元素）、右半边用尽（取左半边的元素）、右半边的当前元素小于左半边的当前元素（取右半边的元素）、右半边的当前元素大于等于左半边的当前元素（取左半边的元素）。<br>——引自橙书</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原地归并</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> mid, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = low, j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> len = high - low + <span class="number">1</span>;</span><br><span class="line">    System.arraycopy(arr, low, mergeHelperArr, low, len);</span><br><span class="line"><span class="comment">//        for(int k=low;k&lt;=high;k++)</span></span><br><span class="line"><span class="comment">//        &#123;</span></span><br><span class="line"><span class="comment">//            temp[k] = ArrToMerge[k];</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=low;k&lt;=high;k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//i++ 先赋值，再加1</span></span><br><span class="line">        <span class="comment">/*语句arr[k] = mergeHelperArr[j++];</span></span><br><span class="line"><span class="comment">        相当于如下两句：</span></span><br><span class="line"><span class="comment">        arr[k] = mergeHelperArr[j];</span></span><br><span class="line"><span class="comment">        j++;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span>(i&gt;mid) arr[k] = mergeHelperArr[j++];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(j&gt;high) arr[k] = mergeHelperArr[i++];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(arr[i]&lt;arr[j]) arr[k] = mergeHelperArr[i++];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(arr[i]&gt;arr[j]) arr[k] = mergeHelperArr[j++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-2-代码实现"><a href="#5-2-代码实现" class="headerlink" title="5.2 代码实现"></a>5.2 代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//归并排序，参考橙书p170</span></span><br><span class="line"><span class="comment">//Top-Down 递归</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] mergeHelperArr; <span class="comment">//辅助数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] MergeSort(<span class="keyword">int</span>[] arr)</span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(<span class="string">"归并排序"</span>);</span><br><span class="line">    mergeHelperArr = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">    <span class="keyword">return</span> mergeHelper(arr, <span class="number">0</span>, arr.length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] mergeHelper(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(high&lt;=low)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//亦为二分查找的mid计算方法，此法可避免(low+high)/2的溢出问题，如low+high&gt;Integer.MAX_VALUE时</span></span><br><span class="line">    <span class="keyword">int</span> mid = low + (high - low)/<span class="number">2</span>;</span><br><span class="line">    mergeHelper(arr, <span class="number">0</span>, mid); <span class="comment">//左半边排序</span></span><br><span class="line">    mergeHelper(arr, mid+<span class="number">1</span>, high); <span class="comment">//右半边排序</span></span><br><span class="line">    merge(arr, low, mid, high); <span class="comment">//归并代码见原地归并方法</span></span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-3-排序过程"><a href="#5-3-排序过程" class="headerlink" title="5.3 排序过程"></a>5.3 排序过程</h4><p>由于递归调用无法直接明白地输出排序过程，可视化可以参考Data Structure Visualizations中比较排序之<a href="https://www.cs.usfca.edu/~galles/visualization/ComparisonSort.html" target="_blank" rel="noopener">归并</a>。</p>
<h4 id="5-4-算法特点"><a href="#5-4-算法特点" class="headerlink" title="5.4 算法特点"></a>5.4 算法特点</h4><p>归并排序能够保证将任意长度为$N$的数组排序所需时间与$NlogN$成正比，主要缺点是需要额外空间与$N$成正比。</p>
<h3 id="6-快速排序"><a href="#6-快速排序" class="headerlink" title="6. 快速排序"></a>6. 快速排序</h3><h4 id="6-1-算法描述"><a href="#6-1-算法描述" class="headerlink" title="6.1 算法描述"></a>6.1 算法描述</h4><p>与归并一样，快排也是分治法的一种应用。其排序的分治过程分三个步骤：</p>
<ul>
<li><strong>分解</strong>：在数组中选择一个元素作为基准（pivot），将数组分为两个子数组，一个比基准小，另一个比基准大；</li>
<li><strong>解决</strong>：通过递归调用快速排序，对两个子数组排序；</li>
<li><strong>合并</strong>：由于两个数组是就地排序的，所以合并不需要操作，整个数组已经排序。</li>
</ul>
<h4 id="6-2-代码实现"><a href="#6-2-代码实现" class="headerlink" title="6.2 代码实现"></a>6.2 代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//快速排序，参考算法导论p85,86</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] QuickSort(<span class="keyword">int</span>[] arr)&#123;</span><br><span class="line">    System.out.println(<span class="string">"快速排序"</span>);</span><br><span class="line">    <span class="keyword">return</span> QSort(arr, <span class="number">0</span>, arr.length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//快速排序递归调用</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] QSort(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(left&gt;=right) <span class="keyword">return</span> arr;</span><br><span class="line">    <span class="keyword">int</span> v = partition(arr, left, right); <span class="comment">//pivot = arr[j]</span></span><br><span class="line">    QSort(arr, left, v-<span class="number">1</span>);</span><br><span class="line">    QSort(arr, v+<span class="number">1</span>, right);</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//数组划分，partition过程</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = left-<span class="number">1</span>, j;</span><br><span class="line">    <span class="keyword">int</span> pivot = arr[right];</span><br><span class="line">    <span class="keyword">for</span>(j=left;j&lt;=right-<span class="number">1</span>;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[j]&lt;=pivot)</span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">            swap(arr, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(arr, i+<span class="number">1</span>, right);</span><br><span class="line">    System.out.printf(<span class="string">"pivot为%d，分割结果为：%s\n"</span>, pivot, Arrays.toString(arr));</span><br><span class="line">    <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-3-排序过程"><a href="#6-3-排序过程" class="headerlink" title="6.3 排序过程"></a>6.3 排序过程</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pivot为25，分割结果为：[4, 7, 17, 0, 11, 25, 34, 116, 129, 31, 27]</span><br><span class="line">pivot为11，分割结果为：[4, 7, 0, 11, 17, 25, 34, 116, 129, 31, 27]</span><br><span class="line">pivot为0，分割结果为：[0, 7, 4, 11, 17, 25, 34, 116, 129, 31, 27]</span><br><span class="line">pivot为4，分割结果为：[0, 4, 7, 11, 17, 25, 34, 116, 129, 31, 27]</span><br><span class="line">pivot为27，分割结果为：[0, 4, 7, 11, 17, 25, 27, 116, 129, 31, 34]</span><br><span class="line">pivot为34，分割结果为：[0, 4, 7, 11, 17, 25, 27, 31, 34, 116, 129]</span><br><span class="line">pivot为129，分割结果为：[0, 4, 7, 11, 17, 25, 27, 31, 34, 116, 129]</span><br></pre></td></tr></table></figure>

<h4 id="6-4-算法特点"><a href="#6-4-算法特点" class="headerlink" title="6.4 算法特点"></a>6.4 算法特点</h4><p>以上数组划分的基准选择的是数组或子数组的最后一个元素，这种方法虽然简单明确，但是并不是一种好的划分方法。因为这种划分方式在输入数组是预排序的或反序的时候，将使快速排序的时间复杂度退化到$O(N^2)$。下面介绍两种较好的pivot选择方法：</p>
<ul>
<li><strong>随机选取：</strong><br>随机选取pivot是比较安全方法，快排的平均复杂度计算一般用随机选取的划分方法。</li>
<li><strong>三数中值分割（Median-of-Three Partitioning）：</strong><br>这方法一般选择数组左端、右端及中心位置三个元素的中值作为pivot。如示例数组<code>{4, 27, 7, 34, 29, 17, 0, 6, 10, 31, 25}</code>中，左端元素为4，右端元素为25，中心元素为17，三数的中值为17，于是pivot选择17。 使用三数中值法消除了预排序输入的情况，减少了快排的运行时间。如下是一种三数中值分割的实现。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//三数中值分割</span></span><br><span class="line"><span class="comment">//需要修改一种简单排序算法的参数，用于在left+3&gt;right的时候使用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Midian3</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = left + (right-left) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(arr[left]&gt;arr[mid]) swap(arr, left, mid);</span><br><span class="line">    <span class="keyword">if</span>(arr[left]&gt;arr[right]) swap(arr, left, right);</span><br><span class="line">    <span class="keyword">if</span>(arr[mid]&gt;arr[right]) swap(arr, mid, right);</span><br><span class="line">    swap(arr, mid, right-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> arr[right-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-堆排序"><a href="#7-堆排序" class="headerlink" title="7. 堆排序"></a>7. 堆排序</h3><h4 id="7-1-算法描述"><a href="#7-1-算法描述" class="headerlink" title="7.1 算法描述"></a>7.1 算法描述</h4><p>堆排序是是一种基于堆这种数据结构的排序方法。堆可以被视为一棵完全二叉树，除最后一层外，堆的每一层都是被填满的。堆具有子节点小于或大于父节点的特点，即堆的最小或最大节点为根节点。堆分为小顶堆和大顶堆。在堆排序中，升序使用大顶堆，降序使用小顶堆。<br>堆排序算法的过程如下：</p>
<ul>
<li><strong>建堆：</strong>将数组构建为大顶堆；</li>
<li><strong>交换元素：</strong>最大元素在堆顶，即<code>arr[0]</code>，将<code>arr[0]</code>与<code>arr[n-1]</code>交换，得到新的数组<code>{arr[0]...arr[n-2]&lt;=arr[n-1]</code>；</li>
<li><strong>保持堆性质：</strong>交换元素后，堆的状态可能不符合堆的性质，需要调用<code>maxHeapify</code>调整为新的堆</li>
<li><strong>重复此过程：</strong>使堆的大小从n-1降到2</li>
</ul>
<h4 id="7-2-代码实现"><a href="#7-2-代码实现" class="headerlink" title="7.2 代码实现"></a>7.2 代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//堆排序，算法导论p74</span></span><br><span class="line"><span class="comment">//升序用大顶堆，降序用小顶堆</span></span><br><span class="line"><span class="comment">//<span class="doctag">TODO:</span>画出堆的状态</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] HeapSort(<span class="keyword">int</span>[] arr)</span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(<span class="string">"堆排序"</span>);</span><br><span class="line">    buildMaxHeap(arr);</span><br><span class="line">    <span class="keyword">int</span> len = arr.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=len-<span class="number">1</span>;i&gt;<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.printf(<span class="string">"%s\n"</span>, Arrays.toString(arr));</span><br><span class="line">        swap(arr, <span class="number">0</span>, i);</span><br><span class="line">        len--;</span><br><span class="line">        maxHeapify(arr, <span class="number">0</span>, len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//建堆</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">buildMaxHeap</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = arr.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=arr.length/<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        maxHeapify(arr, i, len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//保持堆的性质</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">maxHeapify</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> right = <span class="number">2</span> * i + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> largest = i;</span><br><span class="line">    <span class="keyword">if</span>(left&lt;len &amp;&amp; arr[left]&gt;arr[largest])</span><br><span class="line">    &#123;</span><br><span class="line">        largest = left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(right&lt;len &amp;&amp; arr[right]&gt;arr[largest])</span><br><span class="line">    &#123;</span><br><span class="line">        largest = right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(largest!=i)</span><br><span class="line">    &#123;</span><br><span class="line">        swap(arr, i, largest);</span><br><span class="line">        maxHeapify(arr, largest, len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-3-排序过程"><a href="#7-3-排序过程" class="headerlink" title="7.3 排序过程"></a>7.3 排序过程</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">当前堆的状态为：</span><br><span class="line">129 </span><br><span class="line">116 18 34 32 </span><br><span class="line">7 0 4 </span><br><span class="line">11 23 25 </span><br><span class="line">当前数组状态为[129, 116, 18, 34, 32, 7, 0, 4, 11, 23, 25]</span><br><span class="line"></span><br><span class="line">当前堆的状态为：</span><br><span class="line">116 </span><br><span class="line">34 18 25 32 </span><br><span class="line">7 0 4 </span><br><span class="line">11 23 </span><br><span class="line">当前数组状态为[116, 34, 18, 25, 32, 7, 0, 4, 11, 23, 129]</span><br><span class="line"></span><br><span class="line">当前堆的状态为：</span><br><span class="line">34 </span><br><span class="line">32 18 25 23 </span><br><span class="line">7 0 4 </span><br><span class="line">11 </span><br><span class="line">当前数组状态为[34, 32, 18, 25, 23, 7, 0, 4, 11, 116, 129]</span><br><span class="line"></span><br><span class="line">当前堆的状态为：</span><br><span class="line">32 </span><br><span class="line">25 18 11 23 </span><br><span class="line">7 0 4 </span><br><span class="line">当前数组状态为[32, 25, 18, 11, 23, 7, 0, 4, 34, 116, 129]</span><br><span class="line"></span><br><span class="line">当前堆的状态为：</span><br><span class="line">25 </span><br><span class="line">23 18 11 4 </span><br><span class="line">7 0 </span><br><span class="line">当前数组状态为[25, 23, 18, 11, 4, 7, 0, 32, 34, 116, 129]</span><br><span class="line"></span><br><span class="line">当前堆的状态为：</span><br><span class="line">23 </span><br><span class="line">11 18 0 4 </span><br><span class="line">7 </span><br><span class="line">当前数组状态为[23, 11, 18, 0, 4, 7, 25, 32, 34, 116, 129]</span><br><span class="line"></span><br><span class="line">当前堆的状态为：</span><br><span class="line">18 </span><br><span class="line">11 7 0 4 </span><br><span class="line">当前数组状态为[18, 11, 7, 0, 4, 23, 25, 32, 34, 116, 129]</span><br><span class="line"></span><br><span class="line">当前堆的状态为：</span><br><span class="line">11 </span><br><span class="line">4 7 0 </span><br><span class="line">当前数组状态为[11, 4, 7, 0, 18, 23, 25, 32, 34, 116, 129]</span><br><span class="line"></span><br><span class="line">当前堆的状态为：</span><br><span class="line">7 </span><br><span class="line">4 0 </span><br><span class="line">当前数组状态为[7, 4, 0, 11, 18, 23, 25, 32, 34, 116, 129]</span><br><span class="line"></span><br><span class="line">当前堆的状态为：</span><br><span class="line">4 </span><br><span class="line">0 </span><br><span class="line">当前数组状态为[4, 0, 7, 11, 18, 23, 25, 32, 34, 116, 129]</span><br><span class="line"></span><br><span class="line">当前堆的状态为：</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<h4 id="7-4-算法特点"><a href="#7-4-算法特点" class="headerlink" title="7.4 算法特点"></a>7.4 算法特点</h4><p>堆排序是一种原地排序算法，所以其空间复杂度为$O(1)$。</p>
<h2 id="非比较排序"><a href="#非比较排序" class="headerlink" title="非比较排序"></a>非比较排序</h2><h3 id="8-计数排序"><a href="#8-计数排序" class="headerlink" title="8. 计数排序"></a>8. 计数排序</h3><h4 id="8-1-算法描述"><a href="#8-1-算法描述" class="headerlink" title="8.1 算法描述"></a>8.1 算法描述</h4><p>计数排序需要满元素中的每一个都是介于0到k之间的整数。其基本思想为对每一个元素确定小于该元素的元素个数，这样就可以直接把该元素放到最终输出数组中的位置上。如，有5个元素小于元素i，则i的最终位置为5。</p>
<h4 id="8-2-代码实现"><a href="#8-2-代码实现" class="headerlink" title="8.2 代码实现"></a>8.2 代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//计数排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] CountingSort(<span class="keyword">int</span>[] arr)</span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(<span class="string">"计数排序"</span>);</span><br><span class="line">    <span class="keyword">int</span> maxVal = getMaxValue(arr);</span><br><span class="line">    <span class="keyword">int</span>[] bucket = <span class="keyword">new</span> <span class="keyword">int</span>[maxVal+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> iter : arr)</span><br><span class="line">    &#123;</span><br><span class="line">        bucket[iter]++;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.printf(<span class="string">"中间数组为%s\n"</span>, Arrays.toString(bucket));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=maxVal;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(bucket[i]&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            arr[j] = i;</span><br><span class="line">            bucket[i]--;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8-3-排序过程"><a href="#8-3-排序过程" class="headerlink" title="8.3 排序过程"></a>8.3 排序过程</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">中间数组为[1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]</span><br></pre></td></tr></table></figure>

<h3 id="9-桶排序"><a href="#9-桶排序" class="headerlink" title="9. 桶排序"></a>9. 桶排序</h3><h4 id="9-1-算法描述"><a href="#9-1-算法描述" class="headerlink" title="9.1 算法描述"></a>9.1 算法描述</h4><p>当数组符合均匀分布时，应用桶排序可使排序过程以线性期望时间运行。桶排序的基本思想是：</p>
<ul>
<li>建立n个桶，n可为数组大小，桶的跨度为$dis=(maxVal-minVal)/(n-1)$，其中最后一个桶为最大值本身；</li>
<li>遍历数组，把元素放入各个桶中；</li>
<li>对桶内元素排序</li>
<li>遍历各桶，输出元素</li>
</ul>
<h4 id="9-2-代码实现"><a href="#9-2-代码实现" class="headerlink" title="9.2 代码实现"></a>9.2 代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//桶排序，参考程序员小灰</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] BucketSort(<span class="keyword">int</span>[] arrInt)</span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(<span class="string">"桶排序"</span>);</span><br><span class="line">    <span class="keyword">double</span>[] arr = <span class="keyword">new</span> <span class="keyword">double</span>[arrInt.length];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arrInt.length;i++)</span><br><span class="line">        arr[i] = arrInt[i];</span><br><span class="line">    <span class="comment">//1.计算max,min得到差</span></span><br><span class="line">    <span class="keyword">double</span> maxVal = arr[<span class="number">0</span>], minVal = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">double</span> iter : arr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(iter&gt;maxVal) maxVal = iter;</span><br><span class="line">        <span class="keyword">if</span>(iter&lt;minVal) minVal = iter;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> dis = maxVal - minVal;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.建桶</span></span><br><span class="line">    <span class="keyword">int</span> bucketNum = arr.length;</span><br><span class="line">    ArrayList&lt;LinkedList&lt;Double&gt;&gt; bucketList =</span><br><span class="line">            <span class="keyword">new</span> ArrayList&lt;LinkedList&lt;Double&gt;&gt;(bucketNum);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;bucketNum;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        bucketList.add(<span class="keyword">new</span> LinkedList&lt;Double&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.遍历数组，放入桶中</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">double</span> iter : arr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> pos = (<span class="keyword">int</span>)((iter-minVal) * (bucketNum-<span class="number">1</span>) / dis);</span><br><span class="line">        bucketList.get(pos).add(iter);</span><br><span class="line">        System.out.print(<span class="string">"各个桶内元素为"</span>);</span><br><span class="line">        System.out.println(bucketList);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.对桶内进行排序</span></span><br><span class="line">    <span class="keyword">for</span>(LinkedList&lt;Double&gt; iter : bucketList)</span><br><span class="line">    &#123;</span><br><span class="line">        Collections.sort(iter);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//5.依次输出</span></span><br><span class="line">    <span class="keyword">int</span>[] arrReturn = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">    <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(LinkedList&lt;Double&gt; iter : bucketList)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">double</span> ele : iter)</span><br><span class="line">        &#123;</span><br><span class="line">            arrReturn[idx] = (<span class="keyword">int</span>)ele;</span><br><span class="line">            idx++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arrReturn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="9-3-排序过程"><a href="#9-3-排序过程" class="headerlink" title="9.3 排序过程"></a>9.3 排序过程</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">各个桶内元素为[[4.0], [], [], [], [], [], [], [], [], [], []]</span><br><span class="line">各个桶内元素为[[4.0], [23.0], [], [], [], [], [], [], [], [], []]</span><br><span class="line">各个桶内元素为[[4.0, 7.0], [23.0], [], [], [], [], [], [], [], [], []]</span><br><span class="line">各个桶内元素为[[4.0, 7.0], [23.0], [34.0], [], [], [], [], [], [], [], []]</span><br><span class="line">各个桶内元素为[[4.0, 7.0], [23.0], [34.0], [], [], [], [], [], [], [], [129.0]]</span><br><span class="line">各个桶内元素为[[4.0, 7.0], [23.0, 18.0], [34.0], [], [], [], [], [], [], [], [129.0]]</span><br><span class="line">各个桶内元素为[[4.0, 7.0, 0.0], [23.0, 18.0], [34.0], [], [], [], [], [], [], [], [129.0]]</span><br><span class="line">各个桶内元素为[[4.0, 7.0, 0.0], [23.0, 18.0], [34.0], [], [], [], [], [], [116.0], [], [129.0]]</span><br><span class="line">各个桶内元素为[[4.0, 7.0, 0.0, 11.0], [23.0, 18.0], [34.0], [], [], [], [], [], [116.0], [], [129.0]]</span><br><span class="line">各个桶内元素为[[4.0, 7.0, 0.0, 11.0], [23.0, 18.0], [34.0, 32.0], [], [], [], [], [], [116.0], [], [129.0]]</span><br><span class="line">各个桶内元素为[[4.0, 7.0, 0.0, 11.0], [23.0, 18.0, 25.0], [34.0, 32.0], [], [], [], [], [], [116.0], [], [129.0]]</span><br></pre></td></tr></table></figure>

<h3 id="10-基数排序"><a href="#10-基数排序" class="headerlink" title="10.基数排序"></a>10.基数排序</h3><h4 id="10-1-算法描述"><a href="#10-1-算法描述" class="headerlink" title="10.1 算法描述"></a>10.1 算法描述</h4><p>基数排序是一种用在老式穿卡机上的算法。这种算法先按照最低有效位数字进行排序，再对高一位的有效位数字进行排序，直到最高位。</p>
<ul>
<li>取得数组中的最大值，算出其数位；</li>
<li>从对低位开始，根据每一数位进行排序；</li>
</ul>
<h4 id="10-2-代码实现"><a href="#10-2-代码实现" class="headerlink" title="10.2 代码实现"></a>10.2 代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基数排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] RadixSort(<span class="keyword">int</span>[] arr)</span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(<span class="string">"基数排序"</span>);</span><br><span class="line">    <span class="keyword">int</span> radixLen = getRadixLen(getMaxValue(arr));</span><br><span class="line">    <span class="keyword">int</span> radix = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=radixLen;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        countingSort(arr, radix);</span><br><span class="line">        System.out.printf(<span class="string">"当前数位为%d\n"</span>, radix);</span><br><span class="line">        System.out.printf(<span class="string">"排序结果为%s\n"</span>, Arrays.toString(arr));</span><br><span class="line">        radix *= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在各个数位之间用counting sort</span></span><br><span class="line"><span class="comment">//radix为排序的基数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">countingSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> radix)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] bucket = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> iter : arr)</span><br><span class="line">    &#123;</span><br><span class="line">        bucket[(iter/radix)%<span class="number">10</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        bucket[i] += bucket[i-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=arr.length-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        temp[bucket[(arr[i]/radix)%<span class="number">10</span>]-<span class="number">1</span>] = arr[i];</span><br><span class="line">        bucket[(arr[i]/radix)%<span class="number">10</span>]--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//arraycopy的方向为 src==&gt;dst，参数顺序为 src, 复制开始idx, dst, 复制开始idx, 复制长度</span></span><br><span class="line">    System.arraycopy(temp, <span class="number">0</span>, arr, <span class="number">0</span>, arr.length);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获得max的位数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getRadixLen</span><span class="params">(<span class="keyword">int</span> maxVal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(maxVal==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> radixLen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(maxVal!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        maxVal /= <span class="number">10</span>;</span><br><span class="line">        radixLen++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> radixLen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="10-3-排序过程"><a href="#10-3-排序过程" class="headerlink" title="10.3 排序过程"></a>10.3 排序过程</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">当前数位为1</span><br><span class="line">排序结果为[0, 11, 32, 23, 4, 34, 25, 116, 7, 18, 129]</span><br><span class="line">当前数位为10</span><br><span class="line">排序结果为[0, 4, 7, 11, 116, 18, 23, 25, 129, 32, 34]</span><br><span class="line">当前数位为100</span><br><span class="line">排序结果为[0, 4, 7, 11, 18, 23, 25, 32, 34, 116, 129]</span><br></pre></td></tr></table></figure>

<ul>
<li>一些公用函数</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//helper</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMaxValue</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxVal = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> iter : arr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(iter&gt;maxVal) maxVal = iter;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxVal;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*被static修饰的成员变量和成员方法独立于该类的任何对象。也就是说，它不依赖类特定的实例，被类的所有实例共享。</span></span><br><span class="line"><span class="comment">只要这个类被加载，Java虚拟机就能根据类名在运行时数据区的方法区内定找到他们。</span></span><br><span class="line"><span class="comment">因此，static对象可以在它的任何对象创建之前访问，无需引用任何对象  </span></span><br><span class="line"><span class="comment">用public修饰的static成员变量和成员方法本质是全局变量和全局方法，当声明它类的对象市，</span></span><br><span class="line"><span class="comment">不生成static变量的副本，而是类的所有实例共享同一个static变量  </span></span><br><span class="line"><span class="comment">static变量前可以有private修饰，表示这个变量可以在类的静态代码块中，或者类的其他静态成员方法中使用(当然也可以在非静态成员方法中使用)，</span></span><br><span class="line"><span class="comment">但是不能在其他类中通过类名来直接引用，这一点很重要。实际上你需要搞明白，private是访问权限限定，static表示不要实例化就可以使用。</span></span><br><span class="line"><span class="comment">static前面加上其它访问权限关键字的效果也以此类推*/</span></span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>排序算法是算法学习中最基本的问题，而且也是程序员面试中的高频问题。我自己目前在秋招过程中已经被到问到过3次快排了。这篇blog也算是总结一下自己之前的面试。</p>
<p>写的时候不知道，写完才发现可以用泛型。不过主要是为了学习算法，影响不大。之后的二叉搜索树和avl树都用了泛型。全部代码已上传到github上我的项目<a href="https://github.com/Dr-Cube/DataStructuresAlgorithm" target="_blank" rel="noopener">Dr-Cube/DataStructuresAlgorithm</a>。</p>

  </article>
</div>


    




</div>

<div class="footer-wrapper container">
  <footer class="footer clearfix">
    <div class="clearfix">
    <a href="https://dr-cube.github.io" class="footer-logo">
      <i class="fa fa-github"></i>
    </a>
    <ul class="footer-social-link">
      <li>© 2019 jqzhang</li>
      <li><a href="https://dr-cube.github.io">Home</a></li>
      
      <li><a href="https://github.com/Dr-Cube">Github</a></li>
      
    </ul>
    <div class="footer-theme-info">
      Theme <a href="//github.com/sabrinaluo/hexo-theme-replica">Replica</a>
      by <a href="//github.com/sabrinaluo">Hiitea</a> ❤ Powered by Hexo
    </div>
    </div>
    
  </footer>
</div>




<script src="/js/main.js"></script>

</body>
</html>
